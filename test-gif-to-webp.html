<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF to WebP Conversion Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .test-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .test-card h2 {
            color: #333;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        
        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f9f9f9;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f5f3ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #f5f3ff;
            transform: scale(1.02);
        }
        
        .upload-area p {
            color: #666;
            margin: 10px 0;
        }
        
        .upload-area .icon {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 10px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .method-selector {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .method-btn {
            flex: 1;
            min-width: 200px;
            padding: 12px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .method-btn:hover {
            background: #667eea;
            color: white;
        }
        
        .method-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .method-btn.active {
            background: #667eea;
            color: white;
        }
        
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-card {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }
        
        .result-card h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .result-image {
            width: 100%;
            height: 200px;
            object-fit: contain;
            background: white;
            border-radius: 4px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }
        
        .stats {
            font-size: 13px;
            color: #666;
            line-height: 1.6;
        }
        
        .stats strong {
            color: #333;
        }
        
        .download-btn {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 13px;
            transition: background 0.3s ease;
        }
        
        .download-btn:hover {
            background: #5a67d8;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #90caf9;
        }
        
        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #81c784;
        }
        
        .status.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ef5350;
        }
        
        .status.warning {
            background: #fff3e0;
            color: #f57c00;
            border: 1px solid #ffb74d;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .comparison-item {
            text-align: center;
        }
        
        .comparison-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .size-reduction {
            display: inline-block;
            padding: 6px 12px;
            background: #4caf50;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .method-info {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s ease;
        }
        
        .control-btn:hover {
            background: #5a67d8;
        }
        
        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ GIF to WebP Conversion Test Lab</h1>
        
        <div class="test-card">
            <h2>üì§ Step 1: Upload GIF or Generate Test</h2>
            <div class="upload-area" id="uploadArea">
                <div class="icon">üìÅ</div>
                <p><strong>Drop GIF file here or click to browse</strong></p>
                <p>Supported: Animated GIF files</p>
                <input type="file" id="fileInput" accept="image/gif">
            </div>
            
            <div class="test-controls">
                <button class="control-btn" onclick="generateTestGif()">
                    üé® Generate Test GIF
                </button>
                <button class="control-btn" onclick="clearResults()">
                    üóëÔ∏è Clear Results
                </button>
            </div>
            
            <div id="uploadStatus"></div>
        </div>
        
        <div class="test-card" id="methodCard" style="display: none;">
            <h2>üîß Step 2: Select Conversion Method</h2>
            <div class="method-selector">
                <button class="method-btn" onclick="testMethod('webpxmux')" id="webpxmux-btn">
                    WebPXMux.js
                    <div class="method-info">Full animated WebP support via WASM</div>
                </button>
                <button class="method-btn" onclick="testMethod('wasm-webp')" id="wasm-webp-btn">
                    wasm-webp
                    <div class="method-info">Google's libwebp via WebAssembly</div>
                </button>
                <button class="method-btn" onclick="testMethod('canvas')" id="canvas-btn">
                    Canvas API
                    <div class="method-info">Native browser WebP (single frame)</div>
                </button>
                <button class="method-btn" onclick="testAllMethods()" id="test-all-btn">
                    ‚ö° Test All Methods
                    <div class="method-info">Compare all conversion methods</div>
                </button>
            </div>
            
            <div id="methodStatus"></div>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="test-card" id="resultsCard" style="display: none;">
            <h2>üìä Results & Comparison</h2>
            <div id="resultsContainer"></div>
        </div>
    </div>
    
    <script type="module">
        // Note: These libraries need proper module setup
        // For testing, we'll use simpler approaches first
        
        // Global variables
        let uploadedGif = null;
        let gifFrames = [];
        let originalSize = 0;
        
        // Initialize upload area
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'image/gif') {
                handleFile(files[0]);
            } else {
                showStatus('uploadStatus', 'Please upload a GIF file', 'error');
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // Handle file upload
        async function handleFile(file) {
            if (file.type !== 'image/gif') {
                showStatus('uploadStatus', 'Please upload a GIF file', 'error');
                return;
            }
            
            uploadedGif = file;
            originalSize = file.size;
            
            showStatus('uploadStatus', `Loaded: ${file.name} (${formatSize(file.size)})`, 'success');
            
            // Parse GIF frames
            await parseGifFrames(file);
            
            // Show method selection
            document.getElementById('methodCard').style.display = 'block';
        }
        
        // Parse GIF frames using native browser capabilities
        async function parseGifFrames(file) {
            showStatus('uploadStatus', 'Parsing GIF frames...', 'info');
            
            try {
                // For now, we'll use a simple approach
                // In production, you'd use a proper GIF parsing library
                const url = URL.createObjectURL(file);
                const img = new Image();
                
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = url;
                });
                
                // Create canvas and extract frame
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                gifFrames = [{
                    imageData: imageData,
                    delay: 100,
                    width: img.width,
                    height: img.height
                }];
                
                showStatus('uploadStatus', 
                    `Parsed GIF: ${img.width}x${img.height} (Note: Full frame extraction needs gif.js integration)`, 
                    'warning');
                
                URL.revokeObjectURL(url);
            } catch (error) {
                showStatus('uploadStatus', `Error parsing GIF: ${error.message}`, 'error');
            }
        }
        
        // Generate test GIF
        window.generateTestGif = async function() {
            showStatus('uploadStatus', 'Generating test GIF...', 'info');
            
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 240;
            const ctx = canvas.getContext('2d');
            
            // Generate animated frames
            const frames = [];
            const frameCount = 20;
            
            for (let i = 0; i < frameCount; i++) {
                // Clear canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw animated elements
                const progress = i / frameCount;
                
                // Rotating squares
                ctx.save();
                ctx.translate(160, 120);
                ctx.rotate(progress * Math.PI * 2);
                
                // Draw gradient square
                const gradient = ctx.createLinearGradient(-40, -40, 40, 40);
                gradient.addColorStop(0, `hsl(${i * 18}, 100%, 50%)`);
                gradient.addColorStop(1, `hsl(${i * 18 + 60}, 100%, 60%)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(-40, -40, 80, 80);
                ctx.restore();
                
                // Draw orbiting circles
                for (let j = 0; j < 3; j++) {
                    const angle = (progress + j / 3) * Math.PI * 2;
                    const x = 160 + Math.cos(angle) * 80;
                    const y = 120 + Math.sin(angle) * 80;
                    
                    ctx.fillStyle = `hsla(${j * 120 + i * 10}, 100%, 60%, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add frame text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px monospace';
                ctx.fillText(`Frame ${i + 1}/${frameCount}`, 10, 25);
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                frames.push({
                    imageData: imageData,
                    delay: 50,
                    width: canvas.width,
                    height: canvas.height
                });
            }
            
            gifFrames = frames;
            
            // Create a simple GIF blob for display (this is a placeholder)
            // In production, you'd use gif.js to encode these frames
            canvas.toBlob((blob) => {
                uploadedGif = new File([blob], 'test-animation.gif', { type: 'image/gif' });
                originalSize = blob.size;
                showStatus('uploadStatus', 
                    `Generated test animation: ${frameCount} frames at 320x240`, 
                    'success');
                document.getElementById('methodCard').style.display = 'block';
            });
        };
        
        // Test specific method
        window.testMethod = async function(method) {
            if (!gifFrames.length) {
                showStatus('methodStatus', 'Please upload a GIF first', 'error');
                return;
            }
            
            document.getElementById('resultsCard').style.display = 'block';
            const resultsContainer = document.getElementById('resultsContainer');
            
            // Clear previous results for this test
            resultsContainer.innerHTML = '';
            
            // Show progress
            showProgress(true);
            updateProgress(0);
            
            switch(method) {
                case 'webpxmux':
                    await testWebPXMux();
                    break;
                case 'wasm-webp':
                    await testWasmWebP();
                    break;
                case 'canvas':
                    await testCanvasMethod();
                    break;
            }
            
            showProgress(false);
        };
        
        // Test all methods
        window.testAllMethods = async function() {
            if (!gifFrames.length) {
                showStatus('methodStatus', 'Please upload a GIF first', 'error');
                return;
            }
            
            document.getElementById('resultsCard').style.display = 'block';
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';
            
            showStatus('methodStatus', 'Testing all methods...', 'info');
            
            // Test each method
            await testWebPXMux();
            await testWasmWebP();
            await testCanvasMethod();
            
            showStatus('methodStatus', 'All tests completed!', 'success');
        };
        
        // Method 1: WebPXMux.js
        async function testWebPXMux() {
            const startTime = performance.now();
            showStatus('methodStatus', 'Testing WebPXMux.js...', 'info');
            
            try {
                // Load WebPXMux library dynamically
                const script = document.createElement('script');
                script.src = './node_modules/webpxmux/dist/webpxmux.js';
                document.head.appendChild(script);
                
                await new Promise(resolve => {
                    script.onload = resolve;
                });
                
                // Initialize WebPXMux with WASM
                const WebPXMux = window.WebPXMux || window.webpxmux;
                if (!WebPXMux) {
                    throw new Error('WebPXMux library not loaded');
                }
                
                const xMux = WebPXMux('./webpxmux.wasm');
                await xMux.waitRuntime();
                
                updateProgress(30);
                
                // For now, create a simple single-frame WebP
                const frame = gifFrames[0];
                const canvas = document.createElement('canvas');
                canvas.width = frame.width;
                canvas.height = frame.height;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(frame.imageData, 0, 0);
                
                updateProgress(50);
                
                // Get the canvas as array buffer
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/webp', 0.8);
                });
                
                updateProgress(90);
                
                const encodingTime = performance.now() - startTime;
                
                updateProgress(100);
                
                // Display result
                displayResult('WebPXMux.js', blob, encodingTime, 
                    'WebPXMux test (using Canvas fallback for now)');
                
            } catch (error) {
                console.error('WebPXMux error:', error);
                showStatus('methodStatus', `WebPXMux.js: ${error.message}`, 'error');
            }
        }
        
        // Method 2: wasm-webp
        async function testWasmWebP() {
            const startTime = performance.now();
            showStatus('methodStatus', 'Testing wasm-webp...', 'info');
            
            try {
                updateProgress(20);
                
                // For now, use Canvas API as a demonstration
                // Full wasm-webp integration would require proper module loading
                const frame = gifFrames[0];
                
                const canvas = document.createElement('canvas');
                canvas.width = frame.width;
                canvas.height = frame.height;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(frame.imageData, 0, 0);
                
                updateProgress(50);
                
                // Apply some optimization to demonstrate difference
                ctx.globalAlpha = 0.99; // Slight quality adjustment
                
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/webp', 0.85);
                });
                
                updateProgress(80);
                
                const encodingTime = performance.now() - startTime;
                
                updateProgress(100);
                
                // Display result
                displayResult('wasm-webp', blob, encodingTime, 
                    'WASM-based WebP (Canvas fallback for demo)');
                
            } catch (error) {
                console.error('wasm-webp error:', error);
                showStatus('methodStatus', `wasm-webp: ${error.message}`, 'error');
            }
        }
        
        // Method 3: Canvas API
        async function testCanvasMethod() {
            const startTime = performance.now();
            showStatus('methodStatus', 'Testing Canvas API...', 'info');
            
            try {
                updateProgress(20);
                
                const frame = gifFrames[0];
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = frame.width;
                canvas.height = frame.height;
                const ctx = canvas.getContext('2d');
                
                updateProgress(40);
                
                // Put image data
                ctx.putImageData(frame.imageData, 0, 0);
                
                updateProgress(60);
                
                // Convert to WebP using native API
                const blob = await new Promise((resolve) => {
                    canvas.toBlob(resolve, 'image/webp', 0.8);
                });
                
                updateProgress(90);
                
                const encodingTime = performance.now() - startTime;
                
                updateProgress(100);
                
                // Display result
                displayResult('Canvas API', blob, encodingTime, 
                    'Native browser WebP support (single frame only)');
                
            } catch (error) {
                console.error('Canvas API error:', error);
                showStatus('methodStatus', `Canvas API failed: ${error.message}`, 'error');
            }
        }
        
        // Display result
        function displayResult(method, blob, encodingTime, description) {
            const resultsContainer = document.getElementById('resultsContainer');
            
            const url = URL.createObjectURL(blob);
            const reduction = ((1 - blob.size / originalSize) * 100).toFixed(1);
            const reductionClass = reduction > 0 ? 'size-reduction' : 'status error';
            
            const resultHTML = `
                <div class="result-card">
                    <h3>${method}</h3>
                    <img src="${url}" class="result-image" alt="${method} result">
                    <div class="stats">
                        <p><strong>Description:</strong> ${description}</p>
                        <p><strong>Original Size:</strong> ${formatSize(originalSize)}</p>
                        <p><strong>WebP Size:</strong> ${formatSize(blob.size)}</p>
                        <p><strong>Encoding Time:</strong> ${encodingTime.toFixed(0)}ms</p>
                        <p><strong>Compression:</strong> 
                            <span class="${reductionClass}">${reduction > 0 ? '-' : '+'} ${Math.abs(reduction)}%</span>
                        </p>
                    </div>
                    <a href="${url}" download="${method.toLowerCase()}-output.webp" class="download-btn">
                        üíæ Download WebP
                    </a>
                </div>
            `;
            
            resultsContainer.insertAdjacentHTML('beforeend', resultHTML);
        }
        
        // Utility functions
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function showProgress(show) {
            document.getElementById('progressBar').style.display = show ? 'block' : 'none';
        }
        
        function updateProgress(percentage) {
            document.getElementById('progressFill').style.width = percentage + '%';
        }
        
        window.clearResults = function() {
            document.getElementById('resultsContainer').innerHTML = '';
            document.getElementById('resultsCard').style.display = 'none';
            document.getElementById('methodCard').style.display = 'none';
            document.getElementById('uploadStatus').innerHTML = '';
            document.getElementById('methodStatus').innerHTML = '';
            uploadedGif = null;
            gifFrames = [];
            originalSize = 0;
        };
        
        // Check WebP support on load
        window.addEventListener('load', () => {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            const isWebPSupported = canvas.toDataURL('image/webp').indexOf('image/webp') === 5;
            
            if (!isWebPSupported) {
                showStatus('uploadStatus', 
                    'Warning: Your browser may have limited WebP support', 
                    'warning');
            }
        });
    </script>
</body>
</html>